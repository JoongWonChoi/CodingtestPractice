###Greedy_1이 될 때까지(이것이 코딩테스트다)###

## my algorithm ##
#말 그대로 주어진 조건에 따라서 입력된 수 n을 1로 만들어야한다.
#주어진 조건으로는, 또다른 입력된 수 k로 나누어 떨어지면 나누고, 그렇지 않으면 1씩 뺀다.
#반복문을 사용하지 않고 간단한 규칙을 찾아 해결해보려 하였지만, 딱 떨어지는 공식이 없기에 반복문을 이용하였다.
#아주 간단하게, 반복문 내에서 조건을 주어 k로 나누어 떨어지면 나누고, 그렇지 않으면 1씩 빼주는 과정을 반복한다.
#n이 1이 될 때 까지 반복을 진행한다.
#이 때 효울성이 가장 떨어지는 경우는 n의 크기가 범위 최대이고, k가 최소인 2인 경우이다.
#나누는 수가 작을 수록 나누는 횟수가 많아지는건 당연한 사실이기 때문이다.
#k가 최소인 2인경우, n을 반복적으로 2씩 나누기 때문에, n을 1씩만 빼주며 1로 만드는 경우를 n시간 소요된다고 가정하면,
#k가 2일때의 소요되는 시간 T(n) 은 log n + c(상수)가 된다.

##시간복잡도##
#n을 1씩만 빼주며 1로 만드는 경우를 n시간 소요된다고 가정
#k가 최악의 값인 경우(k=2), log n + c만큼 소요
#따라서 항상 최악인 O(logn)보다 좋은 효율로 진행.
#worst case : O(logn)

def untilOne(n, k):
    answer = 0
    while n>1: #n이 1이 될 때까지
        #n이 k로 나누어 떨어지면 나누고
        if n % k == 0:
            n = n // k
        #그렇지 않다면 -1
        else: n -= 1
        answer += 1 #모두 순서를 진행했으므로 결과 += 1
    return answer

#단순 연산을 통해 반복문 없이 알고리즘을 짜보려다가 실패함 ㅎㅎ..
def untilOne2(n, k):
    answer = 0
    answer += n%k
    n -= n%k
    answer += n//k
    return answer

n, k = [int(x) for x in input().split()]
print(untilOne(n,k))