###Greedy_숫자 카드 게임(이것이 코딩테스트다)###

## my algorithm ##
#이 문제는 문제의 의도를 이해하는 것이 가장 중요했던 문제이다.
#각 행에서의 최솟값이 모든 행에서의 최대값이 되는 수의 카드를 찾아야한다.
#즉, 모든 행들의 최솟값을 찾은 후, 그 수들 중 가장 큰 값이 답인 문제이다.
#문제 이해를 마치면, 단순한 이중반복으로 해결과정을 찾을 수 있다.
#문제에서 제시되는 행의 크기 N과 열의 크기 M은 모두 100이하이므로, N*M시간의 이중반복이 최대 10000회밖에 되지 않는다.
#따라서 그렇게 큰 반시간을 소요하지 않기에, 차례로 첫 행부터 min함수를 이용해 최솟값을 찾고,
#다음 행으로 넘어가며 현재 최솟값인 answer보다 다음 행의 최솟값이 더 크면 최신화 해주는 과정을 거치면 된다.

##시간복잡도##
#최대 길이가 M인 행에서의 최솟값을 찾는 과정 * N개의 행에서 탐색하는 과정, 즉 N*M시간이 소요된다.
#이 때 100 >= N,M >= 1이다. (문제 제시)
#나머지 과정은 단순한 연산과정들이므로 상수회 C 소요.
#따라서 O(N*M)시간이 소요된다.
#worst case : O(N*M) (N:행의 크기, M:열의 크기)

def numCard(N,M,num):
    answer = min(num[0]) #처음의 기준을 0번째 행의 최솟값으로 설정
    i = 1 #반복을 위한 인덱스. 0번째 행 다음 행부터 진행
    while i<N: #행의 크기 만큼 반복
        if min(num[i-1]) < min(num[i]):
            answer = min(num[i])
        #다음 순서 행의 최솟값이 현재 최솟값보다 크면 최신화.
        i+=1#다음 행으로 진행
    return answer

#Test Case
N, M = 3, 3
num = [[3,1,2],[4,1,4],[2,2,2]]
print(numCard(N,M,num))

N, M = 2, 4
num = [[7,3,1,8],[3,3,3,4]]
print(numCard(N,M,num))

#n, m = [int(x) for x in input().split()]
