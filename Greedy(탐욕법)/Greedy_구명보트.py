###Greedy_구명보트###

## my algorithm ##
#정해져있는 보트의 무게 limit, 최대 2명까지 태울수 있는 보트에 최소한의 횟수로 사람을 태워 구조해야한다.
#이 문제의 key는 최대 두명까지 태울 수 있는 보트와 보트에 태울 수 있는 limit 이다.
#구조해야할 사람의 무게가 배열로 [50,70,50,80] 이고 보트의 limit이 100 이라면, 첫번째 사람과 세번째 사람을 같이 태우는 것 외에는 모두 한명씩 태워야한다.
#따라서 최소 운송 횟수는 3회가 된다.
#이를 솔루션의 작은 부분으로 나누어 보면, 사람이 한 명 남았을 때와 두 명 남았을 때의 경우로 구분할 수 있다.
#사람이 한 명 남음 = 무조건 운송을 1회 더 해야함
#사람이 두 명 남음 = 두 사람을 한번에 태울지, 나누어 태울지 따져봐야함.. 운송횟수 최대 2회.
#이처럼 진행하기 위해, 사람들 배열 people을 오름차순 정렬하여 경우를 따지기 용이하게 만든다.
#반복을 통해 각 round마다 최대 몇 명 태울 수 있는지 직관적으로 조건문을 통해 확인한 후, 다음 round로 넘어간다.
#이 때,오름차순 정렬된 배열에서 연속된 두명의 합이 limit보다 작으면 둘 다 태울 수 있고, 그렇지 않다면 한명만 태워야 한다.
#두명을 태울 수 있으면 두명 이후의 사람부터 다시 round 진행하고, 한명밖에 못 태우면 태운 사람 이후부터 다시 round진행한다.
#이는 바닥조건을 통해 사람이 한 명 남았을 경우를 제외하고 작은 해결 과정 내에서 탐욕적 선택을 거치면 간결하게 해결 될 문제이다.
#그런데 왜 안되지???
#정렬을 통해 걸리는 시간 nlogn보다 빨리 수행되는 알고리즘이 있는듯 하다..

##시간복잡도##
#최대 people의 길이만큼 반복한다. people 배열 내에서 두명 을 태우면 그만큼 해당 요소가 skip되므로 최대 배열 길이 이하로 반복한다.
#그 전에 people배열을 sort하는 과정에서 nlogn의 시간이 소요된다.
#worst case : O(nlogn) (n=사람 수)



def solution(people, limit):
    answer = 0
    people.sort()
    k = len(people)-1
    i = 0
    while i<len(people):
        if i==k:#사람 한 명 남았을 때(바닥조건)
            answer += 1
            break
            #사람이 한 명 남은 경우 무조건 보트로 1회 옮겨야 함.
        else: #마지막 사람 전의 경우
            if people[i]+people[i+1]<=limit:#연속된 두명의 몸무게 합이 제한 무게보다 적게 나갈 경우
                i += 2 # 두명을 태우므로 그 두명 이후의 사람들로 넘어감.
            else:
                i += 1 # 한명밖에 못태우므로 한 명 태우고 다음 사람으로 넘어감.
            answer += 1  # 보트 1회 운행
    return answer