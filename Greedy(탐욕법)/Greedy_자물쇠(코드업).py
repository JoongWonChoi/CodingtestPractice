###Greedy_자물쇠(코드업)###

## my algorithm ##
#n이 10이면 오름차순으로 정렬된 숫자 리스트 생성
#1. 왼쪽으로 k만큼 밀기, 2. 구간 p~q 뒤집기 3. 다시 왼쪽으로 k만큼 밀기를 실행하여 숫자 자물쇠를 만든다.
#만들어진 숫자 자물쇠가 제공되면, 위의 3번의 동작이 얼만큼 시행되어 만들어진건지 찾아내는 프로그램을 작성해야한다.
#우선 맨 처음에 오름차순으로 정렬된 리스트였기에, 어떠한 동작을 하더라도 마지막 숫자가 아니면 오름차순을 유지해야한다.
#그런데 그 오름차순이 깨지고 오름차순이 아닌 다른 숫자가 다음에 온다면, 뒤집어진 구간과 만난 것이다.
#따라서 달라지는 숫자를 p, 달라지기 이전의 숫자 +1이 되는 인덱스(뒤집어지기 전에 오름차순이었기 때문에)를 q라 하면, 뒤집어진 구간을 찾을 수 있다.
#그 후 q이후의 구간이 왼쪽 밀어넣기 후에 달라진 구간이라고 보고, 왼쪽 밀어넣기 이전의 상태를 찾기 위해 slicing을 이용한다.
#리스트가 밀어넣기 한 만큼 움직였기 때문에 왼쪽 밀어넣기 한 범위를 p와 q에 더해준다.
#뒤집힌 구간을 제대로 만들어주고, 숫자 1이 있는 곳을 찾아서 다시 리스트를 1부터 오름차순이 되도록 만든다.

##시간복잡도##
#반복문을 사용하지만, 가장 많은 반복을 하는 경우는 리스트 길이 n만큼 순회하는 1차 반복문 밖에 없다.
#그 마저도 원하는 조건을 찾으면 반복을 중단한다.
#따라서 최대 n회 내에서 문제 해결이 가능하다.
#worst case : O(n) (n=자물쇠 길이)


def locker(n, num):
    first_left_push = 0 #첫번째 k-왼쪽 밀어넣기
    p, q = 0, 0 #뒤집는 구간
    last_left_push = 0 #마지막 k-왼쪽 밀어넣기
    for i in range(n):
        if i != n: #i가 마지막 숫자가 아니면, 무조건 그 다음 숫자는 i+1 이어야함.
            num[i+1] != num[i]+1 #i번째 인덱스 다음 숫자가 오름차순의 순서가 아니라면 -> reverse된 구간.
            p = i+1 #i를 0부터 시작했으므로.
            break
    for i in range(p,n):
        if num[i] == num[p-1]+1: #reverse되기 이전 숫자의 +1인 부분이 reverse한 마지막 구간.
            q = i
    last_left_push = len(num[q+1:]) #k-왼쪽 밀어넣기 확인하기
    num = num[q+1:] + num[:q+1] #왼쪽 밀어넣기
    print(last_left_push)
    # 밀어넣기 이전의 p와 q의 인덱스. 리스트 움직인 만큼 그대로 연산해준다
    p += last_left_push
    q += last_left_push
    #뒤집힌 구간 원상복구
    p_q = num[p:q+1]
    p_q.reverse()
    #뒤집히기 전까지의 리스트와 뒤집힌 구간 리스트 합하기
    num = num[:p]+p_q
    print(p+1,q+1) #구간 p와q
    idx = num.index(1)
    first_left_push = n-idx #숫자 1의 인덱스부터 리스트 마지막까지 길이.
    print(first_left_push)

n = int(input())
locked_num = [int(x) for x in input().split()]
locker(n,locked_num)
'''
n = 10
locked_num = [9,2,1,10,3,4,5,6,7,8]
locker(n,locked_num)
'''