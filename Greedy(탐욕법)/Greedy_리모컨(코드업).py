###Greedy_리모컨(코드업)###

## my algorithm ##
#현재 온도 n에서 목표 온도 k까지, +1/-1, +5/-5, +10/-10 총 6가지 조작을 통해 목표온도 k까지 도달하는 최소 횟수를 찾아야한다.
#나는 뭔가 임의의 0이상의 정수 n에서 k까지 도달하는데 있어, 연산하기 어려울 것이라고 생각하였다.
#따라서 k - n, 즉 변화를 줘야 하는 온도만큼만을 연산하는 알고리즘을 구상하였다.
#또한 6가지 조작 중 하나씩만을 수행하며 반복하는 것보다(예를 들면 한 round에 +1, 다음 round에 -5 등등..), 조건을 통해 한 round에 가능한 많은 횟수를 확정지을 수 있는 알고리즘으로 진행하였다.
#이는 반복횟수를 조금이나마 줄 일 수 있다.
#조작해야하는 온도 key를 탐욕적으로 상황마다 적절한 선택을 하여 최소 횟수를 찾아낼 수 있는, 그리디 방식의 전형적인 문제였다.
#이 문제의 특징은 +조작 만이 아니라 -조작도 존재하기 때문에 상황에 맞춘 조건문을 적절히 설정해주어야 했다.

##시간복잡도##
#움직여야하는 온도 key를 +1/-1만으로 조작하는 경우, 즉 key만큼의 반복을 수행하는 경우를 n으로 본다.
#그렇다면 아주 최악의 경우 1단위로만 조작 할 때에 O(n)만큼 소요된다.
#하지만 이 문제는 더욱 큰 단위인 5와 10단위로도 조작이 가능하기에 더욱 효율적으로 반복연산이 가능하다고 본다.
#worst case : O(n) (n=key)

def remote_con(n,k):
    answer = 0
    ##추가 : 목표 온도 k가 현재 온도 n보다 낮은 경우도 따져야함!
    #조작해야하는 온도
    key = 0
    if k>n : key = k-n
    else : key = n-k

    while key>0: #key가 0이 될 때까지 반복
        #key가 10보다 크면, 항상 10단위로 조작해야 횟수를 크게 감소시킬 수 있다.
        if key >= 10:
            answer += key // 10
            key %= 10
        #key가 10보다 작은 경우들 따져보기
        elif key < 10:
            #key가 5보다 큰 경우
            if key>5:
                #10으로부터 가까운지, 5로부터 가까운지 판단
                a = 10 % key
                b = key % 5
                if a > b: # 5로부터 가까우면 +5 한 후에 나머지 값들만큼 더해주기
                    answer += b + 1 #5한번 + (1 * b)
                else : answer += a + 1 #그렇지 않으면 +10 한 후 나머지 값들만큼 빼주기
           #key가 5인 경우 +5만 해주면 됨.
            elif key == 5:
                answer += 1
            #key가 5보다 작을 경우, 5로부터 가까운지 0으로부터 가까운지 판단
            else:
                if key>2:
                    answer += (5-key) + 1 #+5 한 후에 나머지 값들만큼 빼주기
                else :
                    answer += key # 나머지 값들만큼 더해주기
            break
    return answer

n, k = [int(x) for x in input().split()]
print(remote_con(n,k))